[{"content":"","date":"15 September 2024","externalUrl":null,"permalink":"/","section":"Glasscat Blog","summary":"","title":"Glasscat Blog","type":"page"},{"content":"","date":"15 September 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"本文将对比着原生Java，帮助透彻的理解spring Bean的生命周期。\nSpring bean的生命周期大致可以分为四个阶段：\n创建\n依赖注入\n初始化\n销毁\n这四个阶段是spring框架内的，下面将对比这理解他们在原生Java中的阶段。\n创建(实例化) # 原生Java：就是对象的实例化，主要是通过构造器方法进行实例化。\nMyBean myBean = new MyBean(); // 这是原生Java中的对象创建 spring框架中：Spring容器通过反射调用类的构造函数来创建Bean的实例。\n依赖注入 # 原生Java：通过setDependency方法，或者obj.feild = xxx直接赋值的方式，给字段进行赋值，也就是注入依赖。\nMyBean myBean = new MyBean(); myBean.setDependency(new Dependency()); // 通过Setter方法注入依赖 spring框架中：Spring容器根据配置或注解，将依赖的Bean注入到目标Bean中。这可以通过@Autowired、@Resource、@Inject等注解，或者通过XML配置中的\u0026lt;property\u0026gt;标签来实现。\n初始化 # 原生Java：Java对象实例化后，调用init之类的方法，进行初始化。\nMyBean myBean = new MyBean(); myBean.init(); // 手动调用初始化方法 spring框架中：Spring提供了InitializingBean接口、@PostConstruct注解或init-methodXML配置，让Bean可以声明自己想要执行的方法，底层仍然是调用了方法。\n销毁 # 原生Java：Java对象任务完成后，调用close或destory方法来进行资源释放之类的工作。\nMyBean myBean = new MyBean(); myBean.destroy(); // 手动调用销毁方法 //额外的提示Java中所有对象的真正销毁和回收都是由GC来决定的 强烈不建议自己调用final方法... spring框架：Spring提供了DisposableBean接口、@PreDestroy注解或destroy-methodXML配置，底层仍然是调用一个销毁方法。\n小结 # 可以看到由Spring框架管理的Bean可以自动化的实现这些工作，降低了耦合与重复性的代码。\n","date":"15 September 2024","externalUrl":null,"permalink":"/posts/spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","section":"Posts","summary":"","title":"Spring中Bean的生命周期","type":"posts"},{"content":"因为亚运会原因，我们开学时间比杭电本校晚了一个月，导致我们这届可能是比较特殊的\u0026hellip;没有校园卡。\n但我本人很想要一张杭电一卡通，所以探索了下，历经两天，成功拿到一卡通。\n一卡通具体流程 # 方法一：线上补卡(推荐) # 1.获取自己的杭电学号，可以通过扫描这张二维码，登录后，点击个人中心，查询自己的学号。\n2.微信搜索“杭电后勤生活”公众号，并关注。关注后，点击智慧服务，就会进入服务大厅，在服务大厅位置点击任意功能，会弹出注册提醒，注册即可。\n注册账号后，继续点击“去认证”，角色选择统一身份认证，即可进入杭电统一身份认证平台。选择账号激活，跟随指引激活并更改密码后。然后用刚激活的账号登录哦，就算完成身份认证了。 成功后如下图：\n3.点击\u0026quot;一卡通\u0026quot;，进入页面后，再点击“预约补卡”，支付20元制卡费后，就算成功了。第二(三)天，就会在微信公众号给你推送制作完成的消息，让你去“后勤服务大厅”取卡了~\n方法二：直接线下补卡 # 我也咨询过“后勤服务大厅”的工作人员，她表示也可以直接线下补卡，当场就能拿卡。（但是因为我没有走过这个流程，可能需要携带 身份证和学生证，欢迎后续有人尝试后补充~）\n后勤服务大厅位置 # 费雷德广场-\u0026gt;文一苑东门-\u0026gt;进门左手边-\u0026gt;后勤服务大厅处领取\n进门后位置\n后勤服务大厅(玻璃门处进入)\n完结 # 至此，恭喜你拿到自己的一卡通了~\n额外补充 # 杭电地图 # 图片来源杭电公众号。 一卡通绑定支付宝和微信 # 如果你是采用的方法一，先进行了账号绑定，后去线上补卡。那么可以很快速的完成一卡通绑定微信/支付宝，也就是可以使用微信/支付宝付款码直接在杭电食堂和超市消费，无需使用一卡通刷卡。(如果未绑定一卡通认证为本校学生，直接使用支付宝/微信付款码将额外收取20%的费用）\n在“杭电后勤生活”公众号，点击“智慧服务”，在服务大厅处，点击“微信(支付宝)绑定指南”，跟随指引完成绑定即可~\n或者直接扫描下面的二维码： 图书馆 # 拿到一卡通后，可以选择去图书馆逛一逛啦！不过有个坏消息要通知你，我们的身份信息并没有被录入到图书馆的门禁系统中。没错，我们可以预约图书馆自习室位置，可以借阅图书馆馆藏书籍，就是无法通过门禁的人脸识别(或一卡通刷卡)进入图书馆。相当的令人哭笑不得\u0026hellip;.\n但是也有个好消息，可以在图书馆门口拿一卡通跟保安阿姨(伯伯)沟通下，表示\u0026quot;我也不知道为什么，反正就是刷不进去，然后纸质登记下，即可进入 : )\u0026quot;\n当然，在进入激动人心图书馆前，还有最有一件事情要做，就是可以先关注“杭电图书馆”公众号，然后跟随指引，完成绑定即可。\n划横线的“我的借阅”功能无法完成绑定，但是(大概率可以)借书，使用图书馆内的借阅机，刷一卡通即可。“座位预约”功能登录后，也可以正常使用。\n杭电的图书馆相当大(个人感觉)，可以乘坐电梯前往想要去的楼层。\n最后 # 🤣不得不说，拿到了一卡通，绑上了支付宝微信，以及绑定了门禁系统的人脸后，对杭电的归属感+1。\n还有就是写的匆忙，有什么不清楚的地方，欢迎私信/线下咨询我下。以及有什么事实性错误或者补充，也欢迎~\n","date":"14 September 2024","externalUrl":null,"permalink":"/posts/guide-to-obtaining-hdu-one-card/","section":"Posts","summary":"","title":"杭电一卡通获取攻略","type":"posts"},{"content":"待施工.\n","externalUrl":null,"permalink":"/about/","section":"Glasscat Blog","summary":"","title":"","type":"page"},{"content":"Spring中对Bean的创建到销毁的全过程都有非常完备的扩展点提供。\n前言 # 我们先来梳理下一个Bean是如何交给Spring管理的，先来简单提及下会涉及到的概念名词。\nBeanFactory(Bean工厂，也就称作IoC容器)，他就是整个Spring最核心的概念，所有Bean都是由他来管理，创造，销毁。\nBeanDefinition(Bean定义)，他是用来描述一个Bean的各种信息，BeanFactory就是根据BeanDefinition来去生成和创建Bean的，可以把他想象成施工的图纸，一切的一切都是根据图纸来的。Bean的元数据被存储在其中，如作用域，类名，属性值。\nBeanFactoryPostProcessor(BeanFactory后处理器)，他可以对BeanFactory进行功能的增强，如果BeanFactory想象成一个工厂车间，那BeanFactory后处理器就是额外的增强插件，可以给工厂添加新的功能。\nBeanPostProcessor(Bean后处理器)，他是对整个BeanFactory中的所有Bean都进额外的拓展，类似于将工厂流水线上的产品统一加上包装，或者让流水线上的产品生产前加点香料，让产品香气扑鼻(哈哈哈)。\nBean真正放到IoC容器中的产品，也就是我们大费周章想要得到的产品！\n总览 # 大致可以分成三个层次的扩展点，BeanFactory级，也就是对应BeanFactoryPostProcessor，对整个工厂进行额外拓展。Bean级，对应着BeanPostProcessor，对工厂内流水线上所有Bean都生效的拓展。具体Bean级，某个Bean单独声明了某些方法。\nBeanFactory级 # 为了更直观的感受整个级别能做的事情，我们先看点实际开发中已经在使用的功能，Spring框架自身就提供了许多的BeanFactoryPostProcessor帮助我们快速开发。\n比如ConfigurationClassPostProcessor用于处理@Configuration注解，PropertyPlaceholderConfigurer用于处理属性占位符。可以跟随下面这段代码感受下。\nDefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); //手动创建一个BeanDefinition /**BeanDefinitionBuilder就是用来创造BeanDefinition的，在genericBeanDefinition中指明 想要创建的类是什么，然后可以用来链式调用去指明想要得到的BeanDefinition的一些属性，如名字，作用域，如何匹配参数（从IoC容器中)，调用哪个构造器等等，然后得到你想要的BeanDefinition了。 */ AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder .genericBeanDefinition(Config.class) .setScope(\u0026#34;singleton\u0026#34;) .getBeanDefinition(); //将BeanDefinition注册进BeanFactory 但是你会发现，config类上的注解并没有被解析。 // 原因在于这些功能不是在BF上，而是在BF后处理器上。 beanFactory.registerBeanDefinition(\u0026#34;config\u0026#34;, beanDefinition); //通过工具类给BF中添加BF后处理器 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); //让BF执行这些后处理器 beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values() .forEach(\tbeanFactoryPostProcessor -\u0026gt; { System.out.println(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34;+beanFactoryPostProcessor); beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); }); 不过我们应用层开发时，很少会注意到这些BeanFactoryPostProcessor的存在，因为他们本质上都是Spring在操作，我们拿到手上的是已经装配的后处理器的工厂。而下面的Bean级才是离我们开发更近的级别。\nBean级 # 这一级别的拓展点相当的丰富，想要彻底搞清楚和理解有哪些拓展点。我们得想从Bean的生命周期开始说起，也可也移步参见我的另一篇博客。\nSpring bean的生命周期大致可以分为四个阶段：\n实例化(对应Java类实例化) 依赖注入(对应Java类设置字段值) 初始化(对应Java类调用init方法) 销毁(对应Java类调用destory方法) Spring提供Bean级拓展点也是围绕着这四个状态展开的。\nBeanPostProcessor 接口：org.springframework.beans.factory.config.BeanPostProcessor 方法： postProcessBeforeInitialization(Object bean, String beanName) postProcessAfterInitialization(Object bean, String beanName) 这两个钩子方法分别是在实例化前和实例化后被调用。\nInstantiationAwareBeanPostProcessor 接口：org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor 继承：继承自BeanPostProcessor 方法： postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) postProcessAfterInstantiation(Object bean, String beanName) postProcessProperties(PropertyValues pvs, Object bean, String beanName) 这三个钩子方法，postProcessProperties在依赖注入之前调用，postProcessBeforeInstantiation在初始化前调用，postProcessAfterInstantiation在初始化后调用。\nDestructionAwareBeanPostProcessor 接口：org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor 继承：继承自BeanPostProcessor 方法： postProcessBeforeDestruction(Object bean, String beanName) 这个钩子方法自然是在销毁之前调用。\n理解了Bean的生命周期，就很轻松的能记住这个六个方法，分别是实例化前后共两个，依赖注入前一个，初始化前后共两个，销毁前一个。\n需要特别留意的是，这个六个Bean级别的方法，是注册到BeanFactory上的，也就是说整个容器中所有的Bean生成时都会触发他们。\nBean自身的方法 # 最后就是Bean自身的方法，大体上分为以下几类。\n初始化方法：@PostConstruct、InitializingBean的afterPropertiesSet()、init-method。 销毁方法：@PreDestroy、DisposableBean的destroy()、destroy-method。 普通方法：通过Spring容器获取Bean实例后手动调用。 构造函数：在Bean实例化时调用。 Setter方法：在依赖注入时调用。 最后 # 整个流程可以参见这张图片~\n","externalUrl":null,"permalink":"/posts/spring%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8B%93%E5%B1%95%E7%82%B9/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]